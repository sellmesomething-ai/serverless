"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const serialize_error_1 = require("serialize-error");
const route_cache_1 = require("../internal/route-cache");
const route_1 = require("../route");
const response_1 = require("./response");
const sendDebugMessage = (debugMessage, ...debugArgs) => {
    process.send && process.send({ debugMessage, debugArgs });
};
const handleError = (err) => {
    if (err) {
        process.send && process.send({ err: (0, serialize_error_1.serializeError)(err) });
    }
};
const handleSuccess = (responseObject) => {
    let reply = { statusCode: 200 };
    if (typeof responseObject === 'string') {
        sendDebugMessage('Sending basic string response');
        reply.headers = { 'Content-Type': 'text/plain' };
        reply.body = responseObject;
    }
    else if (responseObject &&
        typeof responseObject === 'object' &&
        (0, route_1.isTwiml)(responseObject)) {
        sendDebugMessage('Sending TwiML response as XML string');
        reply.headers = { 'Content-Type': 'text/xml' };
        reply.body = responseObject.toString();
    }
    else if (responseObject && responseObject instanceof response_1.Response) {
        sendDebugMessage('Sending custom response');
        reply = responseObject.serialize();
    }
    else {
        sendDebugMessage('Sending JSON response');
        reply.body = responseObject;
        reply.headers = { 'Content-Type': 'application/json' };
    }
    if (process.send) {
        process.send({ reply });
    }
};
process.on('message', ({ functionPath, event, config, path }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield (0, route_cache_1.getRouteMap)(config);
        (0, route_1.constructGlobalScope)(config);
        const context = (0, route_1.constructContext)(config, path);
        sendDebugMessage('Context for %s: %p', path, context);
        sendDebugMessage('Event for %s: %o', path, event);
        let run_timings = {
            start: [0, 0],
            end: [0, 0],
        };
        const callback = (err, responseObject) => {
            run_timings.end = process.hrtime();
            sendDebugMessage('Function execution %s finished', path);
            sendDebugMessage(`(Estimated) Total Execution Time: ${(run_timings.end[0] * 1e9 +
                run_timings.end[1] -
                (run_timings.start[0] * 1e9 + run_timings.start[1])) /
                1e6}ms`);
            if (err) {
                handleError(err);
            }
            else {
                handleSuccess(responseObject);
            }
        };
        sendDebugMessage('Calling function for %s', path);
        run_timings.start = process.hrtime();
        const { handler } = require(functionPath);
        if (typeof handler !== 'function') {
            throw new Error(`Could not find a "handler" function in file ${functionPath}`);
        }
        handler(context, event, callback);
    }
    catch (err) {
        if (process.send) {
            process.send({ err: (0, serialize_error_1.serializeError)(err) });
        }
    }
}));

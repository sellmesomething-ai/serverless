"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDeployInfoCache = exports.getDeployInfoCache = void 0;
const fs_1 = __importDefault(require("fs"));
const ow_1 = __importDefault(require("ow"));
const path_1 = __importDefault(require("path"));
const fs_2 = require("./fs");
const logger_1 = require("./logger");
const debug = (0, logger_1.getDebugFunction)('twilio-run:utils:deployInfoCache');
function validDeployInfoCache(data) {
    try {
        (0, ow_1.default)(data, ow_1.default.object.valuesOfType(ow_1.default.object.exactShape({
            serviceSid: ow_1.default.string.startsWith('ZS').length(34),
            latestBuild: ow_1.default.string.startsWith('ZB').length(34),
        })));
        return true;
    }
    catch (err) {
        debug('Invalid deploy info file %O', err);
        return false;
    }
}
function getDeployInfoCache(baseDir, deployInfoCacheFileName = '.twiliodeployinfo') {
    const fullPath = path_1.default.resolve(baseDir, deployInfoCacheFileName);
    const deployCacheInfoExists = (0, fs_2.fileExistsSync)(fullPath, true);
    if (deployCacheInfoExists) {
        debug('Found deploy info cache at "%s"', fullPath);
        try {
            const rawDeployInfo = fs_1.default.readFileSync(fullPath, 'utf8');
            const deployInfoCache = JSON.parse(rawDeployInfo);
            debug('Parsed deploy info cache file');
            if (validDeployInfoCache(deployInfoCache)) {
                return deployInfoCache;
            }
        }
        catch (err) {
            debug('Failed to read deploy info cache');
        }
    }
    return {};
}
exports.getDeployInfoCache = getDeployInfoCache;
function updateDeployInfoCache(baseDir, username, region = 'us1', deployInfo, deployInfoCacheFileName = '.twiliodeployinfo') {
    const fullPath = path_1.default.resolve(baseDir, deployInfoCacheFileName);
    debug('Read existing deploy info cache');
    const currentDeployInfoCache = getDeployInfoCache(baseDir, deployInfoCacheFileName);
    if (currentDeployInfoCache.hasOwnProperty(username) && region === 'us1') {
        debug('Invalid format for deploy info key. Overriding with region us1');
        debug(`${username}:${region}`);
        delete currentDeployInfoCache[username];
    }
    const newDeployInfoCache = Object.assign(Object.assign({}, currentDeployInfoCache), { [`${username}:${region}`]: deployInfo });
    if (!validDeployInfoCache(newDeployInfoCache)) {
        debug('Invalid format for deploy info cache. Not writing it to disk');
        debug('%P', newDeployInfoCache);
        return;
    }
    debug('Write new deploy info cache');
    try {
        const data = JSON.stringify(newDeployInfoCache, null, '\t');
        fs_1.default.writeFileSync(fullPath, data, 'utf8');
    }
    catch (err) {
        debug('Failed to write deploy info cache. Carrying on without it');
    }
}
exports.updateDeployInfoCache = updateDeployInfoCache;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCodeLocation = exports.UNKNOWN_LOCATION = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
exports.UNKNOWN_LOCATION = {
    line: null,
    filePath: null,
    column: null,
    toString: () => {
        return 'unknown';
    },
};
const STACK_TRACE_REGEX = /.*\((?<fullFilePath>.*):(?<line>\d+):(?<column>\d+)\)$/i;
function getCodeLocation(options = {}) {
    var _a, _b, _c;
    options = Object.assign({ relativeFrom: undefined, offset: 0 }, options);
    const fullStackTrace = new Error().stack;
    if (typeof fullStackTrace !== 'string') {
        return exports.UNKNOWN_LOCATION;
    }
    const stackLines = fullStackTrace.split(os_1.default.EOL);
    // add two to the offset because the first line is "Error" and the next is the location of this function.
    const locationLine = stackLines[(options.offset || 0) + 2];
    if (!locationLine) {
        return exports.UNKNOWN_LOCATION;
    }
    const match = STACK_TRACE_REGEX.exec(locationLine);
    if (match === null) {
        return exports.UNKNOWN_LOCATION;
    }
    const line = parseInt(((_a = match.groups) === null || _a === void 0 ? void 0 : _a.line) || '0', 0);
    const column = parseInt(((_b = match.groups) === null || _b === void 0 ? void 0 : _b.column) || '0', 0);
    let filePath = ((_c = match.groups) === null || _c === void 0 ? void 0 : _c.fullFilePath) || 'unknown';
    if (options.relativeFrom) {
        filePath = path_1.default.relative(options.relativeFrom, filePath);
    }
    const stringVersion = `${filePath}:${line}:${column}`;
    return {
        line,
        column,
        filePath,
        toString: () => stringVersion,
    };
}
exports.getCodeLocation = getCodeLocation;
